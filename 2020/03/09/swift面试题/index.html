<!DOCTYPE html>
<html lang='["zh-CN","en","default"]'>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
      name="viewport"
    />
    <meta content="yes" name="apple-mobile-web-app-capable" />
    <meta
      content="black-translucent"
      name="apple-mobile-web-app-status-bar-style"
    />
    <meta content="telephone=no" name="format-detection" />
    <meta name="description" content="伍佰说：你20多岁的年纪怎么这么痛苦？" />
    <title>swift面试题 | 橘子的皮</title>
    <link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0" />
    <link
      rel="stylesheet"
      type="text/css"
      href="//lib.baomitu.com/normalize/latest/normalize.min.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="//lib.baomitu.com/pure/latest/pure-min.min.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"
    />
    <link
      rel="stylesheet"
      href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"
    />
    <script
      type="text/javascript"
      src="//lib.baomitu.com/jquery/latest/jquery.min.js"
    ></script>
    <link rel="icon" mask="" sizes="any" href="/favicon.ico" />
    <link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png" />
    <script
      type="text/javascript"
      src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"
    ></script>
    <script
      type="text/javascript"
      src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"
    ></script>
    <link
      rel="stylesheet"
      href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"
    />
    <div class="darkmode-toggle">🌓</div>
    <script>
      var prefersDarkMode = window.matchMedia("(prefers-color-scheme: dark)");
      var toggle = document.querySelector(".darkmode-toggle");
      var html = document.querySelector("html");

      html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

      toggle.addEventListener("click", () => {
        localStorage.dark = !(html.dataset.dark == "true");
        html.dataset.dark = localStorage.dark;
      });
    </script>
    <meta name="generator" content="Hexo 7.0.0" />
  </head>
  <body>
    <div class="body_container">
      <div id="header">
        <div class="site-name">
          <h1 class="hidden">swift面试题</h1>
          <a id="logo" href="/.">橘子的皮</a>
          <p class="description">人生苦短，还是要打工还是要打工打工打工</p>
        </div>
        <div id="nav-menu">
          <a class="current" href="/."><i class="fa fa-home"> 首页</i></a
          ><a href="/archives/"><i class="fa fa-archive"> 归档</i></a
          ><a href="/about/"><i class="fa fa-user"> 关于</i></a
          ><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a>
        </div>
      </div>
      <div class="pure-g" id="layout">
        <div class="pure-u-1 pure-u-md-3-4">
          <div class="content_container">
            <div class="post">
              <h1 class="post-title">swift面试题</h1>
              <div class="post-meta">2020-03-09</div>
              <div class="post-content">
                <ul>
                  <li>总结关于 swift 的面试题——持续更新</li>
                  <li>来源于网上、书籍等</li>
                  <li><a href="741136856@qq.com">侵权即删-联系我</a></li>
                </ul>
                <h4 id="1-Class-和-Struct-的区别">
                  <a
                    href="#1-Class-和-Struct-的区别"
                    class="headerlink"
                    title="1.Class 和 Struct 的区别"
                  ></a
                  >1.Class 和 Struct 的区别
                </h4>
                <ul>
                  <li><p>类是引用类型, 结构体为值类型</p></li>
                  <li><p>结构体不可以继承</p></li>
                  <li>
                    <p>
                      值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝
                    </p>
                  </li>
                  <li>
                    <p>
                      引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝
                    </p>
                  </li>
                </ul>
                <span id="more"></span>

                <h4 id="2-理解-Swift-值类型的写时复制">
                  <a
                    href="#2-理解-Swift-值类型的写时复制"
                    class="headerlink"
                    title="2.理解 Swift 值类型的写时复制"
                  ></a
                  >2.理解 Swift 值类型的写时复制
                </h4>
                <ul>
                  <li>
                    <p>只有当一个结构体发生了写入行为时才会有复制行为。</p>
                  </li>
                  <li>
                    <p>
                      在结构体内部用一个引用类型来存储实际的数据，在不进行写入操作的普通传递过程中，都是将内部的
                      reference 的应用计数+1，在进行写入操作时，对内部的
                      reference 做一次 copy 操作用来存储新的数据，防止和之前的
                      reference 产生意外的数据共享。
                    </p>
                  </li>
                  <li>
                    <p>
                      swift
                      中提供该[isKnownUniquelyReferenced]函数，他能检查一个类的实例是不是唯一的引用，如果是，我们就不需要对结构体实例进行复制，如果不是，说明对象被不同的结构体共享，这时对它进行更改就需要进行复制。
                    </p>
                  </li>
                </ul>
                <h4 id="3-defer-的用法">
                  <a
                    href="#3-defer-的用法"
                    class="headerlink"
                    title="3.defer 的用法"
                  ></a
                  >3.defer 的用法
                </h4>
                <ul>
                  <li>
                    <p>
                      使用 defer
                      代码块来表示在函数返回前，函数中最后执行的代码。无论函数是否会抛出错误，这段代码都将执行。
                    </p>
                  </li>
                  <li>
                    <p>
                      defer 语句块中的代码,
                      会在当前作用域结束前调用。每当一个作用域结束就进行该作用域
                      defer 执行。
                    </p>
                    <figure class="highlight swift">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"><span class="keyword">func</span> <span class="title function_">doSomethingFile</span>&#123;</span><br><span class="line">  openDirectory()</span><br><span class="line">  <span class="keyword">defer</span>&#123;</span><br><span class="line">      closeDirectory()</span><br><span class="line">  &#125;</span><br><span class="line">  openFile()</span><br><span class="line">  <span class="keyword">defer</span>&#123;</span><br><span class="line">      closeFile()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// do other things</span></span><br><span class="line">&#125;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                  </li>
                </ul>
                <h4 id="4-inout-输入输出参数">
                  <a
                    href="#4-inout-输入输出参数"
                    class="headerlink"
                    title="4.inout 输入输出参数"
                  ></a
                  >4.inout 输入输出参数
                </h4>
                <ul>
                  <li>
                    <p>
                      函数参数默认为常量。试图从函数主体内部更改函数参数的值会导致编译时错误。这意味着您不能错误地更改参数的值。如果您希望函数修改参数的值，并且希望这些更改在函数调用结束后仍然存在，请将该参数定义为输入输出参数。
                    </p>
                  </li>
                  <li>
                    <p>
                      您可以通过将 inout
                      关键字放在参数类型的前面来编写输入&#x2F;输出参数。一个在出参数具有传递的值中，由函数修改的功能，并将该部分送回出的功能来代替原来的值。有关输入输出参数的行为以及相关的编译器优化的详细讨论，请参见输入输出参数。
                    </p>
                  </li>
                  <li>
                    <p>
                      您只能将变量作为输入输出参数的参数传递。您不能将常量或文字值作为参数传递，因为无法修改常量和文字。当您将一个与号（&amp;）作为变量传入
                      in-out
                      参数时，将它放在变量名的前面，以表明该变量可以被函数修改。
                    </p>
                  </li>
                  <li>
                    <p>
                      注意:输入输出参数不能具有默认值，并且可变参数不能标记为
                      inout。
                    </p>
                    <figure class="highlight swift">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line">  <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">  a <span class="operator">=</span> b</span><br><span class="line">  b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数a本身定义是常量，inout修饰，可以修改a的值</span></span><br><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;someInt is now 107, and anotherInt is now 3&quot;</span></span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                  </li>
                </ul>
                <h4 id="5-什么是高阶函数">
                  <a
                    href="#5-什么是高阶函数"
                    class="headerlink"
                    title="5.什么是高阶函数"
                  ></a
                  >5.什么是高阶函数
                </h4>
                <ul>
                  <li>
                    一个函数如果可以以某一个函数作为参数, 或者是返回值,
                    那么这个函数就称之为高阶函数
                  </li>
                </ul>
                <h4 id="6-static-和-class-的区别">
                  <a
                    href="#6-static-和-class-的区别"
                    class="headerlink"
                    title="6. static 和 class 的区别"
                  ></a
                  >6. static 和 class 的区别
                </h4>
                <ul>
                  <li>
                    在 Swift 中 static 和 class
                    都表示“类型范围作用域”的关键字。在所有类型中（class、static、enum）中，我们可以使用
                    static 来描述类型作用域。class 是专门用于修饰 class 类型的。
                  </li>
                  <li>
                    1.static 可以修饰属性和方法
                    <ul>
                      <li>所修饰的属性和方法不能够被重写。</li>
                      <li>
                        static 修饰的类方法和属性包含了 final
                        关键字的特性，重写会报错
                      </li>
                    </ul>
                  </li>
                  <li>
                    2.class 修饰方法和计算属性
                    <ul>
                      <li>
                        我们同样可以使用 class
                        修饰方法和计算属性，但是不能够修饰存储属性。
                      </li>
                      <li>
                        类方法和计算属性是可以被重写的，可以使用 class
                        关键字也可以是 static
                      </li>
                    </ul>
                  </li>
                </ul>
                <h4 id="7-自定义模式匹配模式">
                  <a
                    href="#7-自定义模式匹配模式"
                    class="headerlink"
                    title="7.自定义模式匹配模式"
                  ></a
                  >7.自定义模式匹配模式
                </h4>
                <ul>
                  <li>
                    <p>
                      可参考
                      <a
                        target="_blank"
                        rel="noopener"
                        href="https://www.cnblogs.com/wjw-blog/p/11674857.html"
                        >swift 模式和模式匹配</a
                      >
                    </p>
                  </li>
                  <li>
                    <p>
                      模式：<br />代表单个或者复合值得结构，也就是说模式不是一个特定的值，它是一种抽象的结构，【一句话，不是特指，是泛指】。这样就可以用模式来匹配各种各样的值。
                      -
                      例如：(x,y)可以匹配元祖（1.2），以及任何包含两个元素的元组。<br />除了利用模式匹配一个值以外，你可以从复合值中提取出部分或全部值，然后把各个部分的值和一个常量或变量绑定起来。
                    </p>
                  </li>
                  <li>
                    <p>swift 中的模式分为两类：</p>
                    <ul>
                      <li>
                        一种能匹配任何类型的值，另一种在运行时匹配某个特定的值，可能会失败。
                      </li>
                      <li>
                        第一种模式用于结构简单变量，常量和可选绑定中的值。此类模式包括通配符模式，标识符模式，以及包含前两种模式的值绑定模式和元组模式。你可以为这类模式指定一个类型标注，从而限制它们只能匹配某种特定类型的值。
                      </li>
                      <li>
                        第二种模式用于全局模式匹配。这种情况下，你试图匹配的值在运行时可能不存在。此类模式包括枚举用例模式，可选模式，表达式模式和类型转换模式。你在
                        switch 语句的 case 标签中，do 语句的 catch
                        子句中，或者再 if,while,guard,for-in 语句的 case
                        条件语句中使用这类模式。
                      </li>
                    </ul>
                  </li>
                  <li>
                    <p>重载 ～&#x3D; 该运算符</p>
                    <figure class="highlight swift">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"><span class="keyword">switch</span> <span class="number">80</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;eighty&quot;</span>:</span><br><span class="line">  <span class="comment">//编译通过并且匹配</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;not eighty&quot;</span>:</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">     <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上代码编译直接失败失败</span></span><br><span class="line"><span class="comment">//重载 ～= 函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">~=</span> (<span class="params">pattern</span>: <span class="type">String</span>, <span class="params">value</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"> 	   <span class="keyword">if</span> pattern <span class="operator">==</span> <span class="string">&quot;eighty&quot;</span> &#123;</span><br><span class="line">     	<span class="keyword">return</span> value <span class="operator">==</span> <span class="number">80</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> pattern <span class="operator">==</span> <span class="string">&quot;not eighty&quot;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> value <span class="operator">!=</span> <span class="number">80</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> <span class="number">80</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;eighty&quot;</span>:</span><br><span class="line">   <span class="comment">//编译通过并且匹配</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;not eighty&quot;</span>:</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line"> 	     <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">该<span class="keyword">switch</span>编译通过</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                  </li>
                </ul>
                <h4 id="8-dynamic-framework-和-static-framework-的区别是什么">
                  <a
                    href="#8-dynamic-framework-和-static-framework-的区别是什么"
                    class="headerlink"
                    title="8.dynamic framework 和 static framework 的区别是什么"
                  ></a
                  >8.dynamic framework 和 static framework 的区别是什么
                </h4>
                <ul>
                  <li>
                    <p>
                      可参考<a
                        target="_blank"
                        rel="noopener"
                        href="https://www.cnblogs.com/junhuawang/p/7598236.html"
                        >该文章</a
                      >
                    </p>
                  </li>
                  <li>
                    <p>
                      静态库和动态库, 静态库是每一个程序单独打包一份,
                      而动态库则是多个程序之间共享
                    </p>
                  </li>
                  <li>
                    <p>
                      静态库和动态库是相对编译期和运行期的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入，因为在程序运行期间还需要动态库的存在。
                    </p>
                  </li>
                  <li>
                    <p>静态库 好处：</p>
                    <ul>
                      <li>
                        模块化，分工合作，提高了代码的复用及核心技术的保密程度
                      </li>
                      <li>避免少量改动经常导致大量的重复编译连接</li>
                      <li>也可以重用，注意不是共享使用</li>
                    </ul>
                  </li>
                  <li>
                    <p>动态库 好处：</p>
                    <ul>
                      <li>
                        使用动态库，可以将最终可执行文件体积缩小，将整个应用程序分模块，团队合作，进行分工，影响比较小
                      </li>
                      <li>
                        使用动态库，多个应用程序共享内存中得同一份库文件，节省资源
                      </li>
                      <li>
                        使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。
                      </li>
                    </ul>
                  </li>
                  <li>
                    <p>不同点：</p>
                    <ul>
                      <li>
                        静态库在链接时，会被完整的复制到可执行文件中，如果多个
                        App 都使用了同一个静态库，那么每个 App
                        都会拷贝一份，缺点是浪费内存。类似于定义一个基本变量，使用该基本变量是是新复制了一份数据，而不是原来定义的；
                      </li>
                      <li>
                        动态库不会复制，只有一份，程序运行时动态加载到内存中，系统只会加载一次，多个程序共用一份，节约了内存。类似于使用变量的内存地址一样，使用的是同一个变量；
                      </li>
                    </ul>
                  </li>
                  <li>
                    <p>共同点：</p>
                    <ul>
                      <li>
                        静态库和动态库都是闭源库，只能拿来满足某个功能的使用，不会暴露内部具体的代码信息
                      </li>
                    </ul>
                  </li>
                </ul>
                <h4 id="9-Swift-与-Objective-C-的联系与区别？">
                  <a
                    href="#9-Swift-与-Objective-C-的联系与区别？"
                    class="headerlink"
                    title="9. Swift 与 Objective-C 的联系与区别？"
                  ></a
                  >9. Swift 与 Objective-C 的联系与区别？
                </h4>
                <ul>
                  <li>
                    Swift 和 Objective-C 共用一套运行时环境，Swift
                    的类型可以桥接到 Objective-C（下面我简称
                    OC），反之亦然。两者可以互相引用混合编程。<br />其次就是，OC
                    之前积累的很多类库，在 Swift
                    中大部分依然可以直接使用，当然，Swift3
                    之后，一些语法改变了很多，不过还是有迹可循的。OC
                    出现过的绝大多数概念，比如引用计数、ARC、属性、协议、接口、初始化、扩展类、命名参数、匿名函数等，在
                    Swift 中继续有效（可能最多换个术语）。Swift 大多数概念与 OC
                    一样。当然 Swift 也多出了一些新兴概念，这些在 OC
                    中是没有的，比如范型、元组等。
                  </li>
                </ul>
                <h4 id="10-Swift-比-Objective-C-有什么优势？">
                  <a
                    href="#10-Swift-比-Objective-C-有什么优势？"
                    class="headerlink"
                    title="10. Swift 比 Objective-C 有什么优势？"
                  ></a
                  >10. Swift 比 Objective-C 有什么优势？
                </h4>
                <ul>
                  <li>Swift 容易阅读，语法和文件结构简易化。</li>
                  <li>Swift 更易于维护，文件分离后结构更清晰。</li>
                  <li>Swift 更加安全，它是类型安全的语言。</li>
                  <li>Swift 代码更少，简洁的语法，可以省去大量冗余代码。</li>
                  <li>Swift 速度更快，运算性能更高。</li>
                </ul>
                <h4 id="11-Swift-是面向对象还是函数式的编程语言">
                  <a
                    href="#11-Swift-是面向对象还是函数式的编程语言"
                    class="headerlink"
                    title="11.Swift 是面向对象还是函数式的编程语言?"
                  ></a
                  >11.Swift 是面向对象还是函数式的编程语言?
                </h4>
                <ul>
                  <li>
                    <p>
                      Swift 既是面向对象的，又是函数式的编程语言。<br />说 Swift
                      是面向对象的语言，是因为 Swift
                      支持类的封装、继承、和多态，从这点上来看与 Java
                      这类纯面向对象的语言几乎毫无差别。
                    </p>
                  </li>
                  <li>
                    <p>
                      说 Swift 是函数式编程语言，是因为 Swift 支持 map, reduce,
                      filter, flatmap
                      这类去除中间状态、数学函数式的方法，更加强调运算结果而不是中间过程。
                    </p>
                  </li>
                </ul>
                <h4
                  id="12-请说明并比较以下关键词：Open-Public-Internal-File-private-Private"
                >
                  <a
                    href="#12-请说明并比较以下关键词：Open-Public-Internal-File-private-Private"
                    class="headerlink"
                    title="12.请说明并比较以下关键词：Open, Public, Internal, File-private, Private"
                  ></a
                  >12.请说明并比较以下关键词：Open, Public, Internal,
                  File-private, Private
                </h4>
                <ul>
                  <li>
                    <p>
                      Swift 有五个级别的访问控制权限，从高到底依次为比如 Open,
                      Public, Internal, File-private, Private。
                    </p>
                  </li>
                  <li>
                    <p>
                      他们遵循的基本原则是：高级别的变量不允许被定义为低级别变量的成员变量。比如一个
                      private 的 class 中不能含有 public 的
                      String。反之，低级别的变量却可以定义在高级别的变量中。比如
                      public 的 class 中可以含有 private 的 Int。
                    </p>
                  </li>
                  <li>
                    <p>
                      Open 具备最高的访问权限。其修饰的类和方法可以在任意 Module
                      中被访问和重写；它是 Swift 3 中新添加的访问权限。
                    </p>
                  </li>
                  <li>
                    <p>
                      Public 的权限仅次于 Open。与 Open
                      唯一的区别在于它修饰的对象可以在任意 Module
                      中被访问，但不能重写。
                    </p>
                  </li>
                  <li>
                    <p>
                      Internal 是默认的权限。它表示只能在当前定义的 Module
                      中访问和重写，它可以被一个 Module
                      中的多个文件访问，但不可以被其他的 Module 中被访问。
                    </p>
                  </li>
                  <li>
                    <p>
                      File-private 也是 Swift 3
                      新添加的权限。其被修饰的对象只能在当前文件中被使用。例如它可以被一个文件中的
                      class，extension，struct 共同使用。
                    </p>
                  </li>
                  <li>
                    <p>
                      Private
                      是最低的访问权限。它的对象只能在定义的作用域内使用。离开了这个作用域，即使是同一个文件中的其他作用域，也无法访问。
                    </p>
                  </li>
                </ul>
                <h4 id="13-请说明并比较以下关键词：strong-weak-unowned">
                  <a
                    href="#13-请说明并比较以下关键词：strong-weak-unowned"
                    class="headerlink"
                    title="13.请说明并比较以下关键词：strong, weak, unowned"
                  ></a
                  >13.请说明并比较以下关键词：strong, weak, unowned
                </h4>
                <ul>
                  <li>
                    <p>
                      Swift 的内存管理机制与 Objective-C 一样为 ARC（Automatic
                      Reference
                      Counting）。它的基本原理是，一个对象在没有任何强引用指向它时，其占用的内存会被回收。反之，只要有任何一个强引用指向该对象，它就会一直存在于内存中。
                    </p>
                  </li>
                  <li>
                    <p>
                      strong 代表着强引用，是默认属性。当一个对象被声明为 strong
                      时，就表示父层级对该对象有一个强引用的指向。此时该对象的引用计数会增加
                      1。
                    </p>
                  </li>
                  <li>
                    <p>
                      weak 代表着弱引用。当对象被声明为 weak
                      时，父层级对此对象没有指向，该对象的引用计数不会增加
                      1。它在对象释放后弱引用也随即消失。继续访问该对象，程序会得到
                      nil，不亏崩溃
                    </p>
                  </li>
                  <li>
                    <p>
                      unowned
                      与弱引用本质上一样。唯一不同的是，对象在释放后，依然有一个无效的引用指向对象，它不是
                      Optional 也不指向 nil。如果继续访问该对象，程序就会崩溃。
                    </p>
                  </li>
                  <li>
                    <p>加分回答：</p>
                    <ul>
                      <li>
                        <p>
                          weak 和 unowned 的引入是为了解决由 strong
                          带来的循环引用问题。简单来说，就是当两个对象互相有一个强指向去指向对方，这样导致两个对象在内存中无法释放。
                        </p>
                      </li>
                      <li>
                        <p>weak 和 unowned 的使用场景有如下差别：</p>
                        <ul>
                          <li>
                            当访问对象时该对象可能已经被释放了，则用 weak。比如
                            delegate 的修饰。
                          </li>
                          <li>
                            当访问对象确定不可能被释放，则用 unowned。比如 self
                            的引用。
                          </li>
                          <li>
                            实际上为了安全起见，很多公司规定任何时候都使用 weak
                            去修饰。
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
                <h4
                  id="14-说说-Swift-为什么将-String，Array，Dictionary-设计成值类型？"
                >
                  <a
                    href="#14-说说-Swift-为什么将-String，Array，Dictionary-设计成值类型？"
                    class="headerlink"
                    title="14. 说说 Swift 为什么将 String，Array，Dictionary 设计成值类型？"
                  ></a
                  >14. 说说 Swift 为什么将 String，Array，Dictionary
                  设计成值类型？
                </h4>
                <p>
                  要解答这个问题，就要和 Objective-C
                  中相同的数据结构设计进行比较。Objective-C
                  中，字符串，数组，字典，皆被设计为引用类型。
                </p>
                <ul>
                  <li>
                    <p>
                      值类型相比引用类型，最大的优势在于内存使用的高效。值类型在栈上操作，引用类型在堆上操作。栈上的操作仅仅是单个指针的上下移动，而堆上的操作则牵涉到合并、移位、重新链接等。也就是说
                      Swift 这样设计，大幅减少了堆上的内存分配和回收的次数。同时
                      copy-on-write 又将值传递和复制的开销降到了最低。
                    </p>
                  </li>
                  <li>
                    <p>
                      String，Array，Dictionary
                      设计成值类型，也是为了线程安全考虑。通过 Swift 的 let
                      设置，使得这些数据达到了真正意义上的“不变”，它也从根本上解决了多线程中内存访问和操作顺序的问题。
                    </p>
                  </li>
                  <li>
                    <p>
                      设计成值类型还可以提升 API 的灵活度。例如通过实现
                      Collection 这样的协议，我们可以遍历
                      String，使得整个开发更加灵活高效。
                    </p>
                  </li>
                </ul>
                <h4 id="15-闭包是引用类型吗？">
                  <a
                    href="#15-闭包是引用类型吗？"
                    class="headerlink"
                    title="15. 闭包是引用类型吗？"
                  ></a
                  >15. 闭包是引用类型吗？
                </h4>
                <ul>
                  <li>
                    闭包是引用类型。如果一个闭包被分配给一个变量，这个变量复制给另一个变量，那么他们引用的是同一个闭包，他们的捕捉列表也会被复制。
                  </li>
                </ul>
                <h4 id="16-Swift-mutating-关键字的使用？">
                  <a
                    href="#16-Swift-mutating-关键字的使用？"
                    class="headerlink"
                    title="16.Swift mutating 关键字的使用？"
                  ></a
                  >16.Swift mutating 关键字的使用？
                </h4>
                <ul>
                  <li>
                    类是引用类型，而结构和枚举是值类型。默认情况下，不能在其实例方法中修改值类型的属性。为了修改值类型的属性，必须在实例方法中使用
                    mutating
                    关键字。使用此关键字，您的方法将能够更改属性的值，并在方法实现结束时将其写回到原始结构
                  </li>
                </ul>
                <h4 id="17-Swift-定义常量-和-OC-定义常量的区别？">
                  <a
                    href="#17-Swift-定义常量-和-OC-定义常量的区别？"
                    class="headerlink"
                    title="17.Swift 定义常量 和 OC 定义常量的区别？"
                  ></a
                  >17.Swift 定义常量 和 OC 定义常量的区别？
                </h4>
                <figure class="highlight vbnet">
                  <table>
                    <tr>
                      <td class="gutter">
                        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>
                      </td>
                      <td class="code">
                        <pre><span class="line"><span class="symbol">OC:</span></span><br><span class="line"><span class="keyword">const</span> int price = <span class="number">0</span>;</span><br><span class="line"><span class="symbol">Swift:</span></span><br><span class="line"><span class="keyword">let</span> price = <span class="number">0</span></span><br></pre>
                      </td>
                    </tr>
                  </table>
                </figure>

                <ul>
                  <li>
                    OC 中用 const 来表示常量，而 Swift 中用 let 来判断是不是常量
                  </li>
                  <li>OC 中 const 常量类型和数值是在编译时确定的</li>
                  <li>
                    Swift 中 let
                    常量（只能赋值一次),其类型和值既可以是静态的，也可以是一个动态的计算方法，它们在运行时确定的。
                  </li>
                </ul>
                <h4 id="18-闭包">
                  <a href="#18-闭包" class="headerlink" title="18. 闭包"></a>18.
                  闭包
                </h4>
                <ul>
                  <li>
                    <p>
                      <code>闭包和函数是引用类型</code
                      >，将函数或闭包赋值给一个常量还是变量，实际上都是将常量或变量的值设置为对应函数或闭包的引用。
                    </p>
                    <figure class="highlight swift">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeInCount</span>(<span class="params">count</span>: <span class="type">Int</span>) -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">incrementer</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        total <span class="operator">+=</span> count</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> incrementBySeven <span class="operator">=</span> makeInCount(count: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()</span><br><span class="line"><span class="keyword">let</span> alsoIncrementBySeven <span class="operator">=</span> incrementBySeven</span><br><span class="line">alsoIncrementBySeven()</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                  </li>
                  <li>
                    <p>
                      <code>逃逸闭包</code
                      >，当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注
                      @escaping，用来指明这个闭包是允许“逃逸”出这个函数的。
                      例如网络请求 ⬇️
                    </p>
                    <figure class="highlight swift">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"><span class="keyword">func</span> <span class="title function_">request</span>(<span class="params">result</span>:<span class="keyword">@escaping</span>((<span class="type">String</span>)-&gt;()))&#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(wallDeadline: <span class="type">DispatchWallTime</span>.now() <span class="operator">+</span> <span class="number">10</span>) &#123;</span><br><span class="line">        result(<span class="string">&quot;数据结果&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                  </li>
                  <li>
                    <p>
                      <code>非逃逸闭包</code>,
                      永远不会离开一个函数的局部作用域的闭包就是非逃逸闭包。
                    </p>
                    <figure class="highlight swift">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"><span class="keyword">func</span> <span class="title function_">player</span>(<span class="params">complete</span>:(<span class="type">Bool</span>)-&gt;())&#123;</span><br><span class="line">    complete(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                  </li>
                  <li>
                    <p>
                      <code>自动闭包</code
                      >，自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。当闭包作为参数传入
                      可用@autoclosure 标记闭包参数
                      ，可将参数当函数调用而并非以闭包的形式。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包
                    </p>
                    <figure class="highlight swift">
                      <table>
                        <tr>
                          <td class="gutter">
                            <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>
                          </td>
                          <td class="code">
                            <pre><span class="line"><span class="keyword">var</span> customersInLine <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“5”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> customerProvider <span class="operator">=</span> &#123; customersInLine.remove(at: <span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“5”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line"><span class="comment">// 打印出“Now serving Chris!”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(customersInLine.count)</span><br><span class="line"><span class="comment">// 打印出“4”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// customersInLine is [&quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: customersInLine.remove(at: <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 打印“Now serving Ewa!”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不用  @autoclosure 修饰</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">serve</span>(<span class="params">customer</span> <span class="params">customerProvider</span>: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now serving <span class="subst">\(customerProvider())</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">serve(customer: &#123; customersInLine.remove(at: <span class="number">0</span>) &#125; )</span><br><span class="line"><span class="comment">//打印“Now serving Ewa!”</span></span><br></pre>
                          </td>
                        </tr>
                      </table>
                    </figure>
                  </li>
                </ul>
                <h4 id="19-关于-unowned-weak-的使用">
                  <a
                    href="#19-关于-unowned-weak-的使用"
                    class="headerlink"
                    title="19.关于 unowned &amp; weak 的使用"
                  ></a
                  >19.关于 unowned &amp; weak 的使用
                </h4>
                <ul>
                  <li>
                    <code>week</code>弱引用
                    <ul>
                      <li>使用场景：被捕获的引用可能会变为 nil 时</li>
                    </ul>
                  </li>
                  <li>
                    <code>unowned</code> 无主引用
                    <ul>
                      <li>
                        使用场景：闭包和捕获的实例总是相互引用并且同时销毁时
                      </li>
                    </ul>
                  </li>
                  <li>
                    为什么不直接都用 week，解包使用呢？
                    <ul>
                      <li>
                        可以使用 unowned 解决，但是用
                        weak，会产生额外的开销，比如需要解包等
                      </li>
                      <li>与 week 相反，unowned 不需要解包，增加效率</li>
                    </ul>
                  </li>
                </ul>
              </div>
              <div class="tags"></div>
              <div class="post-nav">
                <a
                  class="pre"
                  href="/2020/06/16/%E5%B8%B8%E7%94%A8Git%20%E5%91%BD%E4%BB%A4%20%E6%B8%85%E5%8D%95%E9%80%9F%E6%9F%A5/"
                  >常用Git 命令 清单速查</a
                >
              </div>
            </div>
          </div>
        </div>
        <div class="pure-u-1-4 hidden_mid_and_down">
          <div id="sidebar">
            <div class="widget">
              <form
                class="search-form"
                action="//www.google.com/search"
                method="get"
                accept-charset="utf-8"
                target="_blank"
              >
                <input
                  type="text"
                  name="q"
                  maxlength="20"
                  placeholder="Search"
                /><input
                  type="hidden"
                  name="sitesearch"
                  value="http://example.com"
                />
              </form>
            </div>
            <div class="widget">
              <div class="widget-title">
                <i class="fa fa-folder-o"> 分类</i>
              </div>
            </div>
            <div class="widget">
              <div class="widget-title"><i class="fa fa-star-o"> 标签</i></div>
              <div class="tagcloud"></div>
            </div>
            <div class="widget">
              <div class="widget-title">
                <i class="fa fa-file-o"> 最近文章</i>
              </div>
              <ul class="post-list">
                <li class="post-list-item">
                  <a class="post-list-link" href="/2024/02/29/qaql/"
                    >钱哪去里了-用户协议和隐私政策</a
                  >
                </li>
                <li class="post-list-item">
                  <a
                    class="post-list-link"
                    href="/2023/12/05/Certbot%20%E9%85%8D%E7%BD%AE%E6%B3%9B%E5%9F%9F%E5%90%8D/"
                    >Let’s Encrypt 免费泛域名配置</a
                  >
                </li>
                <li class="post-list-item">
                  <a
                    class="post-list-link"
                    href="/2021/10/26/iOS%20Android%20%E6%89%93%E5%8C%85%E5%88%86%E5%8F%91%E6%8F%92%E4%BB%B6%20fastlane-plugin-notifyworker%20%E9%80%82%E7%94%A8%E4%BA%8E%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%EF%BC%8C%E9%92%89%E9%92%89/"
                    >iOS Android 打包分发插件 fastlane-plugin-notifyworker
                    适用于企业微信，钉钉</a
                  >
                </li>
                <li class="post-list-item">
                  <a
                    class="post-list-link"
                    href="/2021/02/23/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B9%B1%E7%9A%84OC%E9%9D%A2%E8%AF%95%E9%A2%98/"
                    >一些杂乱的 OC 面试题</a
                  >
                </li>
                <li class="post-list-item">
                  <a
                    class="post-list-link"
                    href="/2020/12/16/%E4%BD%BF%E7%94%A8iTerm2%E7%BB%88%E7%AB%AF%E6%89%93%E5%BC%80iOS,Mac%E9%A1%B9%E7%9B%AE/"
                    >快捷方式：iTerm2/终端 打开 iOS/Mac 项目</a
                  >
                </li>
                <li class="post-list-item">
                  <a
                    class="post-list-link"
                    href="/2020/07/27/Ubuntu%20+%20Django%20+%20Uwsgi%20+%20Nginx%20%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2/"
                    >Ubuntu + Django + Uwsgi + Nginx 线上部署</a
                  >
                </li>
                <li class="post-list-item">
                  <a
                    class="post-list-link"
                    href="/2020/06/16/%E5%B8%B8%E7%94%A8Git%20%E5%91%BD%E4%BB%A4%20%E6%B8%85%E5%8D%95%E9%80%9F%E6%9F%A5/"
                    >常用Git 命令 清单速查</a
                  >
                </li>
                <li class="post-list-item">
                  <a
                    class="post-list-link"
                    href="/2020/03/09/swift%E9%9D%A2%E8%AF%95%E9%A2%98/"
                    >swift面试题</a
                  >
                </li>
              </ul>
            </div>
            <div class="widget">
              <div class="widget-title">
                <i class="fa fa-external-link"> 友情链接</i>
              </div>
            </div>
          </div>
        </div>
        <div class="pure-u-1 pure-u-md-3-4">
          <div id="footer">
            Copyright © 2024
            <a href="/." rel="nofollow">橘子的皮. 赣ICP备2023012875号.</a>
            Powered by<a rel="nofollow" target="_blank" href="https://hexo.io">
              Hexo.</a
            ><a
              rel="nofollow"
              target="_blank"
              href="https://github.com/tufu9441/maupassant-hexo"
            >
              Theme</a
            >
            by<a
              rel="nofollow"
              target="_blank"
              href="https://github.com/pagecho"
            >
              Cho.</a
            >
          </div>
        </div>
      </div>
      <a class="show" id="rocket" href="#top"></a>
      <script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script>
      <script
        type="text/javascript"
        src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"
      ></script>
      <script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script>
      <link
        rel="stylesheet"
        type="text/css"
        href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"
      />
      <script
        type="text/javascript"
        src="/js/copycode.js?v=1.0.0"
        successtext="复制成功！"
      ></script>
      <link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0" />
      <script
        type="text/javascript"
        src="/js/codeblock-resizer.js?v=1.0.0"
      ></script>
      <script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script>
    </div>
  </body>
</html>
